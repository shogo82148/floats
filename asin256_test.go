package floats

import (
	"math"
	"testing"
)

func TestFloat256_Asin(t *testing.T) {
	tests := []struct {
		x    Float256
		want string
	}{
		{exact256(-1), "-1.570796326794896619231321691639751442098584699687552910487472296153908203143104499"},
		{exact256(-0.75), "-0.8480620789814810080529443389984180800733662132631126428607181635702008212284742343"},
		{exact256(-0.5), "-0.5235987755982988730771072305465838140328615665625176368291574320513027343810348331"},
		{exact256(-0.25), "-0.2526802551420786534856574369937109722521937330968381936339237787405750604810212224"},
		{exact256(0.25), "0.2526802551420786534856574369937109722521937330968381936339237787405750604810212224"},
		{exact256(0.5), "0.5235987755982988730771072305465838140328615665625176368291574320513027343810348331"},
		{exact256(0.75), "0.8480620789814810080529443389984180800733662132631126428607181635702008212284742343"},
		{exact256(1), "1.570796326794896619231321691639751442098584699687552910487472296153908203143104499"},
	}

	for _, tt := range tests {
		got := tt.x.Asin()
		if !close256(got, tt.want) {
			t.Errorf("Asin(%v) = %v; want %v", tt.x, got, tt.want)
		}
	}

	strictTests := []struct {
		x    Float256
		want Float256
	}{
		// special cases
		{exact256(0), exact256(0)},
		{exact256(math.Copysign(0, -1)), exact256(math.Copysign(0, -1))},
		{exact256(math.NaN()), exact256(math.NaN())},
		{exact256(2), exact256(math.NaN())},
		{exact256(-2), exact256(math.NaN())},
	}

	for _, tt := range strictTests {
		got := tt.x.Asin()
		if !eq256(got, tt.want) {
			t.Errorf("Asin(%v) = %v; want %v", tt.x, got, tt.want)
		}
	}
}

func TestFloat256_Atan(t *testing.T) {
	tests := []struct {
		x    Float256
		want string
	}{
		{exact256(-0.5), "-0.4636476090008061162142562314612144020285370542861202638109330887201978641657417053"},
		{exact256(-0.25), "-0.2449786631268641541720824812112758109141440983811840671273759146673551195876420966"},
		{exact256(-0.125), "-0.1243549945467614350313548491638710255731701917698040899151141191157222674275667586"},
		{exact256(0.125), "0.1243549945467614350313548491638710255731701917698040899151141191157222674275667586"},
		{exact256(0.25), "0.2449786631268641541720824812112758109141440983811840671273759146673551195876420966"},
		{exact256(0.5), "0.4636476090008061162142562314612144020285370542861202638109330887201978641657417053"},
		{exact256(0.75), "0.6435011087932843868028092287173226380415105911153123828656061187135124748116210887"},
		{exact256(1), "0.7853981633974483096156608458198757210492923498437764552437361480769541015715522497"},
		{exact256(2), "1.107148717794090503017065460178537040070047645401432646676539207433710338977362794"},
		{exact256(math.Inf(-1)), "-1.570796326794896619231321691639751442098584699687552910487472296153908203143104499"},
		{exact256(math.Inf(1)), "1.570796326794896619231321691639751442098584699687552910487472296153908203143104499"},
	}

	for _, tt := range tests {
		got := tt.x.Atan()
		if !close256(got, tt.want) {
			t.Errorf("Atan(%v) = %v; want %v", tt.x, got, tt.want)
		}
	}

	strictTests := []struct {
		x    Float256
		want Float256
	}{
		// special cases
		{exact256(0), exact256(0)},
		{exact256(math.Copysign(0, -1)), exact256(math.Copysign(0, -1))},
		{exact256(math.NaN()), exact256(math.NaN())},
	}

	for _, tt := range strictTests {
		got := tt.x.Atan()
		if !eq256(got, tt.want) {
			t.Errorf("Atan(%v) = %v; want %v", tt.x, got, tt.want)
		}
	}
}
