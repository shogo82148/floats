package floats

import (
	"math"
	"runtime"
	"testing"
)

func TestFloat256_Log1p(t *testing.T) {
	tests := []struct {
		x    Float256
		want string
	}{
		{exact256(-0.5), "-0.6931471805599453094172321214581765680755001343602552541206800094933936219696947156"},
		{exact256(-0.25), "-0.2876820724517809274392190059938274315035097108977610565066656853492929507207804643"},
		{exact256(0), "0"},
		{exact256(0x1p-256), "8.636168555094444625386351862800399571116000364436281385023703470168591803162389766E-78"},
		{exact256(0.25), "0.2231435513142097557662950903098345033746010855480072136712878724873917437682683334"},
		{exact256(0.5), "0.4054651081081643819780131154643491365719904234624941976140143241441006712489142513"},
		{exact256(1), "0.6931471805599453094172321214581765680755001343602552541206800094933936219696947156"},
		{exact256(2), "1.098612288668109691395245236922525704647490557822749451734694333637494293218608967"},
		{exact256(3), "1.386294361119890618834464242916353136151000268720510508241360018986787243939389431"},
		{exact256(10), "2.397895272798370544061943577965129299821706853937417175218567709130573623913236713"},
	}

	for _, tt := range tests {
		got := tt.x.Log1p()
		if !close256(got, tt.want) {
			t.Errorf("Log1p(%v) = %v; want %v", tt.x, got, tt.want)
		}
	}

	strictTests := []struct {
		x    Float256
		want Float256
	}{
		// special cases
		{exact256(math.Inf(1)), exact256(math.Inf(1))},
		{exact256(0), exact256(0)},
		{exact256(math.Copysign(0, -1)), exact256(math.Copysign(0, -1))},
		{exact256(-1), exact256(math.Inf(-1))},
		{exact256(-2), exact256(math.NaN())},
		{exact256(math.NaN()), exact256(math.NaN())},
	}

	for _, tt := range strictTests {
		got := tt.x.Log1p()
		if !eq256(got, tt.want) {
			t.Errorf("Log1p(%v) = %v; want %v", tt.x, got, tt.want)
		}
	}
}

func BenchmarkFloat256_Log1p(b *testing.B) {
	x := NewFloat256(1.5)
	for b.Loop() {
		runtime.KeepAlive(x.Log1p())
	}
}
