package floats

import (
	"math"
	"runtime"
	"testing"
)

func TestFloat128_Log1p(t *testing.T) {
	tests := []struct {
		x    Float128
		want string
	}{
		{exact128(-0.5), "-0.6931471805599453094172321214581765680755001343602552541206800094933936219696947156"},
		{exact128(-0.25), "-0.2876820724517809274392190059938274315035097108977610565066656853492929507207804643"},
		{exact128(0), "0"},
		{exact128(0x1p-25), "2.980232194360611147319705384762092811636641842845025377945055083910522928327110498E-8"},
		{exact128(0x1p-128), "2.938735877055718769921841343055614194542345807652671581459186089764642948851268392E-39"},
		{exact128(0.25), "0.2231435513142097557662950903098345033746010855480072136712878724873917437682683334"},
		{exact128(0.5), "0.4054651081081643819780131154643491365719904234624941976140143241441006712489142513"},
		{exact128(1), "0.6931471805599453094172321214581765680755001343602552541206800094933936219696947156"},
		{exact128(2), "1.098612288668109691395245236922525704647490557822749451734694333637494293218608967"},
		{exact128(3), "1.386294361119890618834464242916353136151000268720510508241360018986787243939389431"},
		{exact128(10), "2.397895272798370544061943577965129299821706853937417175218567709130573623913236713"},
	}

	for _, tt := range tests {
		got := tt.x.Log1p()
		if !close128(got, tt.want) {
			t.Errorf("Log1p(%v) = %v; want %v", tt.x, got, tt.want)
		}
	}

	strictTests := []struct {
		x    Float128
		want Float128
	}{
		// special cases
		{exact128(math.Inf(1)), exact128(math.Inf(1))},
		{exact128(0), exact128(0)},
		{exact128(math.Copysign(0, -1)), exact128(math.Copysign(0, -1))},
		{exact128(-1), exact128(math.Inf(-1))},
		{exact128(-2), exact128(math.NaN())},
		{exact128(math.NaN()), exact128(math.NaN())},
	}

	for _, tt := range strictTests {
		got := tt.x.Log1p()
		if !eq128(got, tt.want) {
			t.Errorf("Log1p(%v) = %v; want %v", tt.x, got, tt.want)
		}
	}
}

func BenchmarkFloat128_Log1p(b *testing.B) {
	x := NewFloat128(1.5)
	for b.Loop() {
		runtime.KeepAlive(x.Log1p())
	}
}
