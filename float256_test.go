package floats

import (
	"math"
	"runtime"
	"testing"
)

func TestFloat256_IsNaN(t *testing.T) {
	tests := []struct {
		name string
		a    Float256
		want bool
	}{
		{
			name: "NaN",
			a: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},
		{
			name: "infinity",
			a: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.a.IsNaN(); got != tt.want {
				t.Errorf("Float256.IsNaN() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestFloat256_IsInf(t *testing.T) {
	inf := Float256{
		0x7fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	}
	neginf := Float256{
		0xffff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	}
	one := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	}

	tests := []struct {
		in   Float256
		sign int
		want bool
	}{
		// infinity
		{inf, 1, true},
		{inf, -1, false},
		{inf, 0, true},

		// -infinity
		{neginf, 1, false},
		{neginf, -1, true},
		{neginf, 0, true},

		// +1.1(finite)
		{one, 1, false},
	}

	for _, tt := range tests {
		got := tt.in.IsInf(tt.sign)
		if got != tt.want {
			t.Errorf("Float256.IsInf(%v) = %v, want %v", tt.in, got, tt.want)
		}
	}
}

func BenchmarkFloat256_IsInf(b *testing.B) {
	f := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	}
	for b.Loop() {
		runtime.KeepAlive(f.IsInf(0))
	}
}

func TestFloat256_Signbit(t *testing.T) {
	tests := []struct {
		in   Float256
		want bool
	}{
		{
			// 1.0
			in: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
		{
			// -1.0
			in: Float256{
				0xbfff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},
	}

	for _, tt := range tests {
		got := tt.in.Signbit()
		if got != tt.want {
			t.Errorf("Float256.Signbit() = %v, want %v", got, tt.want)
		}
	}
}

func BenchmarkFloat256_Signbit(b *testing.B) {
	f := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	}
	for b.Loop() {
		runtime.KeepAlive(f.Signbit())
	}
}

func TestFloat256_Copysign(t *testing.T) {
	tests := []struct {
		a, sign, want Float256
	}{
		{exact256(10), exact256(-1), exact256(-10)},
		{exact256(10), exact256(1), exact256(10)},
		{exact256(0), exact256(-1), exact256(math.Copysign(0, -1))},
	}
	for _, tt := range tests {
		got := tt.a.Copysign(tt.sign)
		if !eq256(got, tt.want) {
			t.Errorf("Float256(%x).Copysign(%x) = %x, want %x", tt.a, tt.sign, got, tt.want)
		}
	}
}

func TestFloat256_Int64(t *testing.T) {
	tests := []struct {
		in  Float256
		out int64
	}{
		{
			// 0.0
			in: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			out: 0,
		},
		{
			// 1.0
			in: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			out: 1,
		},
		{
			// 0.5
			in: Float256{
				0x3fff_e000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			out: 0,
		},
		{
			// -1.0
			in: Float256{
				0xbfff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			out: -1,
		},
	}

	for _, tt := range tests {
		got := tt.in.Int64()
		if got != tt.out {
			t.Errorf("Float256.Int64() = %v, want %v", got, tt.out)
		}
	}
}

func BenchmarkFloat256_Int64(b *testing.B) {
	f := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	}
	for b.Loop() {
		runtime.KeepAlive(f.Int64())
	}
}

func TestFloat256_IsZero(t *testing.T) {
	tests := []struct {
		a    Float256
		want bool
	}{
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},
		{
			// -0.0
			a: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
	}
	for _, tt := range tests {
		got := tt.a.IsZero()
		if got != tt.want {
			t.Errorf("Float256.IsZero() = %v, want %v", got, tt.want)
		}
	}
}

func TestFloat256_Neg(t *testing.T) {
	tests := []struct {
		a, want Float256
	}{
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -1.0
			want: Float256{
				0xbfff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -0.0
			want: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// -0.0
			a: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// +inf
			a: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -inf
			want: Float256{
				0xffff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// -inf
			a: Float256{
				0xffff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +inf
			want: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// NaN
			a: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
	}

	for _, tt := range tests {
		got := tt.a.Neg()
		if !eq256(got, tt.want) {
			t.Errorf("Float256(%x).Neg() = %x, want %x", tt.a, got, tt.want)
		}
	}
}

func TestFloat256_Abs(t *testing.T) {
	tests := []struct {
		a, want Float256
	}{
		{exact256(1.0), exact256(1.0)},
		{exact256(-1.0), exact256(1.0)},
		{exact256(0), exact256(0)},
		{exact256(math.Copysign(0, -1)), exact256(0)},
		{exact256(math.Inf(1)), exact256(math.Inf(1))},
		{exact256(math.Inf(-1)), exact256(math.Inf(1))},
		{exact256(math.NaN()), exact256(math.NaN())},
	}
	for _, tt := range tests {
		got := tt.a.Abs()
		if !eq256(got, tt.want) {
			t.Errorf("Float256.Abs() = %x, want %x", got, tt.want)
		}
	}
}

func TestFloat256_Mul(t *testing.T) {
	tests := []struct {
		a, b, want Float256
	}{
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 2.0
			b: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 2.0
			want: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 2.0
			a: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0001,
			},
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0002,
			},
		},

		// underflow
		{
			// 0.25
			a: Float256{
				0x3fff_d000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0001,
			},
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},

		// overflow
		{
			// 2.0
			a: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			b: Float256{
				0x7fff_e000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},

		// handling zero
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// -0.0
			a: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -0.0
			want: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -1.0
			b: Float256{
				0xbfff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -0.0
			want: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// -0.0
			a: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -1.0
			b: Float256{
				0xbfff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},

		// handling NaN
		{
			// NaN
			a: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			b: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},

		// handling infinity
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +inf
			b: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +inf
			want: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// -1.0
			a: Float256{
				0xbfff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +inf
			b: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -inf
			want: Float256{
				0xffff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// +inf
			a: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +inf
			want: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// +inf
			a: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -1.0
			b: Float256{
				0xbfff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -inf
			want: Float256{
				0xffff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// +inf
			a: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +Inf
			b: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
	}

	for _, tt := range tests {
		got := tt.a.Mul(tt.b)
		if !eq256(got, tt.want) {
			t.Errorf("Float256(%x).Mul(%x) = %x, want %x", tt.a, tt.b, got, tt.want)
		}
	}
}

func BenchmarkFloat256_Mul(b *testing.B) {
	f := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	}
	for b.Loop() {
		runtime.KeepAlive(f.Mul(f))
	}
}

func TestFloat256_Quo(t *testing.T) {
	tests := []struct {
		a, b, want Float256
	}{
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			want: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},

		// zero division
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +Inf
			want: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},

		// handling NaN
		{
			// NaN
			a: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			b: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},

		// handling infinity
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// inf
			b: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// inf
			a: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// inf
			want: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// inf
			a: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// inf
			b: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
	}

	for _, tt := range tests {
		got := tt.a.Quo(tt.b)
		if !eq256(got, tt.want) {
			t.Errorf("Float256(%x).Quo(%x) = %x, want %x", tt.a, tt.b, got, tt.want)
		}
	}
}

func BenchmarkFloat256_Quo(b *testing.B) {
	f := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	}
	for b.Loop() {
		runtime.KeepAlive(f.Quo(f))
	}
}

func TestFloat256_Add(t *testing.T) {
	tests := []struct {
		a, b, want Float256
	}{
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 2.0
			want: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0001,
			},
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0001,
			},
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0002,
			},
		},

		// handling zero
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			want: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			want: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -0.0
			b: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// -0.0
			a: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// -0.0
			a: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -0.0
			b: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -0.0
			want: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},

		// handling NaN
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			b: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// NaN
			a: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},

		// handling infinity
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +inf
			b: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +inf
			want: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// +inf
			a: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +inf
			want: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// +inf
			a: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +inf
			b: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +Inf
			want: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// +inf
			a: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -inf
			b: Float256{
				0xffff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
	}

	for _, tt := range tests {
		got := tt.a.Add(tt.b)
		if !eq256(got, tt.want) {
			t.Errorf("Float256(%x).Add(%x) = %x, want %x", tt.a, tt.b, got, tt.want)
		}
	}
}

func BenchmarkFloat256_Add(b *testing.B) {
	f := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	} // 1.0
	for b.Loop() {
		runtime.KeepAlive(f.Add(f))
	}
}

func TestFloat256_Sub(t *testing.T) {
	tests := []struct {
		a, b, want Float256
	}{
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 2.0
			b: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -1.0
			want: Float256{
				0xbfff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},

		// handling zero
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -1.0
			want: Float256{
				0xbfff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			want: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -0.0
			b: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// -0.0
			a: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -0.0
			want: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// -0.0
			a: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -0.0
			b: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 0.0
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},

		// handling NaN
		{
			// NaN
			a: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			b: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},

		// handling infinity
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +inf
			b: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -inf
			want: Float256{
				0xffff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// +inf
			a: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +inf
			want: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// +inf
			a: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// +inf
			b: Float256{
				0x7fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			want: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
	}

	for _, tt := range tests {
		got := tt.a.Sub(tt.b)
		if !eq256(got, tt.want) {
			t.Errorf("Float256(%x).Sub(%x) = %x, want %x", tt.a, tt.b, got, tt.want)
		}
	}
}

func BenchmarkFloat256_Sub(b *testing.B) {
	f := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	} // 1.0
	for b.Loop() {
		runtime.KeepAlive(f.Sub(f))
	}
}

func TestFloat256_Sqrt(t *testing.T) {
	tests := []struct {
		a, want Float256
	}{
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			want: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 2.0
			a: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			want: Float256{
				0x3fff_f6a0_9e66_7f3b,
				0xcc90_8b2f_b136_6ea9,
				0x57d3_e3ad_ec17_5127,
				0x7509_9da2_f590_b066,
			},
		},
	}

	for _, tt := range tests {
		got := tt.a.Sqrt()
		if !eq256(got, tt.want) {
			t.Errorf("Float256(%x).Sqrt() = %x, want %x", tt.a, got, tt.want)
		}
	}
}

func BenchmarkFloat256_Sqrt(b *testing.B) {
	f := Float256{
		0x4000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	} // 2.0
	for b.Loop() {
		runtime.KeepAlive(f.Sqrt())
	}
}

func TestFloat256_Eq(t *testing.T) {
	tests := []struct {
		a, b Float256
		want bool
	}{
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},

		// handling zero
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -0.0
			b: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},

		// handling NaN
		{
			// NaN
			a: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			b: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
	}

	for _, tt := range tests {
		got := tt.a.Eq(tt.b)
		if got != tt.want {
			t.Errorf("Float256(%x).Eq(%x) = %v, want %v", tt.a, tt.b, got, tt.want)
		}
	}
}

func BenchmarkFloat256_Eq(b *testing.B) {
	f := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	} // 1.0
	for b.Loop() {
		runtime.KeepAlive(f.Eq(f))
	}
}

func TestFloat256_Ne(t *testing.T) {
	tests := []struct {
		a, b Float256
		want bool
	}{
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},

		// handling zero
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -0.0
			b: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},

		// handling NaN
		{
			// NaN
			a: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			b: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},
	}

	for _, tt := range tests {
		got := tt.a.Ne(tt.b)
		if got != tt.want {
			t.Errorf("Float256(%x).Ne(%x) = %v, want %v", tt.a, tt.b, got, tt.want)
		}
	}
}

func BenchmarkFloat256_Ne(b *testing.B) {
	f := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	} // 1.0
	for b.Loop() {
		runtime.KeepAlive(f.Ne(f))
	}
}

func TestFloat256_Lt(t *testing.T) {
	tests := []struct {
		a, b Float256
		want bool
	}{
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 2.0
			b: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},
		{
			// 2.0
			a: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},

		// handling zero
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0001,
			},
			want: true,
		},
		{
			// -0.0
			a: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			b: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0001,
			},
			want: true,
		},

		// handling NaN
		{
			// NaN
			a: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			b: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
	}

	for _, tt := range tests {
		got := tt.a.Lt(tt.b)
		if got != tt.want {
			t.Errorf("Float256(%x).Lt(%x) = %v, want %v", tt.a, tt.b, got, tt.want)
		}
	}
}

func BenchmarkFloat256_Lt(b *testing.B) {
	f := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	} // 1.0
	for b.Loop() {
		runtime.KeepAlive(f.Lt(f))
	}
}

func TestFloat256_Gt(t *testing.T) {
	tests := []struct {
		a, b Float256
		want bool
	}{
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 2.0
			b: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0001,
			},
			want: false,
		},
		{
			// 2.0
			a: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},

		// handling zero
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -0.0
			b: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
		{
			// -0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0001,
			},
			b: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},

		// handling NaN
		{
			// NaN
			a: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			b: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
	}

	for _, tt := range tests {
		got := tt.a.Gt(tt.b)
		if got != tt.want {
			t.Errorf("Float256(%x).Gt(%x) = %v, want %v", tt.a, tt.b, got, tt.want)
		}
	}
}

func BenchmarkFloat256_Gt(b *testing.B) {
	f := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	} // 1.0
	for b.Loop() {
		runtime.KeepAlive(f.Gt(f))
	}
}

func TestFloat256_Le(t *testing.T) {
	tests := []struct {
		a, b Float256
		want bool
	}{
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 2.0
			b: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0001,
			},
			want: true,
		},
		{
			// 2.0
			a: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},

		// handling zero
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -0.0
			b: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},

		// handling NaN
		{
			// NaN
			a: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			b: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
	}

	for _, tt := range tests {
		got := tt.a.Le(tt.b)
		if got != tt.want {
			t.Errorf("Float256(%x).Le(%x) = %v, want %v", tt.a, tt.b, got, tt.want)
		}
	}
}

func BenchmarkFloat256_Le(b *testing.B) {
	f := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	} // 1.0
	for b.Loop() {
		runtime.KeepAlive(f.Le(f))
	}
}

func TestFloat256_Ge(t *testing.T) {
	tests := []struct {
		a, b Float256
		want bool
	}{
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 2.0
			b: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0001,
			},
			want: false,
		},
		{
			// 2.0
			a: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},

		// handling zero
		{
			// 0.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// -0.0
			b: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: true,
		},

		// handling NaN
		{
			// NaN
			a: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// 1.0
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
		{
			// 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			// NaN
			b: Float256{
				0x7fff_f800_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: false,
		},
	}

	for _, tt := range tests {
		got := tt.a.Ge(tt.b)
		if got != tt.want {
			t.Errorf("Float256(%x).Ge(%x) = %v, want %v", tt.a, tt.b, got, tt.want)
		}
	}
}

func BenchmarkFloat256_Ge(b *testing.B) {
	f := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	} // 1.0
	for b.Loop() {
		runtime.KeepAlive(f.Ge(f))
	}
}

func TestFMA256(t *testing.T) {
	tests := []struct {
		a, b, c, want Float256
	}{
		{
			// 1.0 * 1.0 + 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			c: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: Float256{
				0x4000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 1.0 * 1.0 - 2.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			c: Float256{
				0xc000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: Float256{
				0xbfff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			// 1.0 * 1.0 - 1.0
			a: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			c: Float256{
				0xbfff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},

		// special cases
		{
			// 0 * 1.0 - 1.0
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			b: Float256{
				0x3fff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			c: Float256{
				0xbfff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: Float256{
				0xbfff_f000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
		{
			a: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0001,
			},
			b: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0001,
			},
			c: Float256{
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
			want: Float256{
				0x8000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
				0x0000_0000_0000_0000,
			},
		},
	}

	for _, tt := range tests {
		got := FMA256(tt.a, tt.b, tt.c)
		if !eq256(got, tt.want) {
			t.Errorf("FMA256(%x, %x, %x) = %x, want %x", tt.a, tt.b, tt.c, got, tt.want)
		}
	}
}

func BenchmarkFMA256(b *testing.B) {
	f := Float256{
		0x3fff_f000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
		0x0000_0000_0000_0000,
	} // 1.0
	for b.Loop() {
		runtime.KeepAlive(FMA256(f, f, f))
	}
}

func TestFloat256_Nextafter(t *testing.T) {
	tests := []struct {
		x, y, want Float256
	}{
		{
			exact256(0), exact256(1),
			Float256{0x0000_0000_0000_0000, 0x0000_0000_0000_0000, 0x0000_0000_0000_0000, 0x0000_0000_0000_0001},
		},
		{
			exact256(0), exact256(-1),
			Float256{0x8000_0000_0000_0000, 0x0000_0000_0000_0000, 0x0000_0000_0000_0000, 0x0000_0000_0000_0001},
		},
		{
			exact256(1), exact256(2),
			Float256{0x3fff_f000_0000_0000, 0x0000_0000_0000_0000, 0x0000_0000_0000_0000, 0x0000_0000_0000_0001},
		},
		{
			exact256(1), exact256(0),
			Float256{0x3fff_efff_ffff_ffff, 0xffff_ffff_ffff_ffff, 0xffff_ffff_ffff_ffff, 0xffff_ffff_ffff_ffff},
		},
		{
			exact256(-1), exact256(-2),
			Float256{0xbfff_f000_0000_0000, 0x0000_0000_0000_0000, 0x0000_0000_0000_0000, 0x0000_0000_0000_0001},
		},
		{
			exact256(-1), exact256(0),
			Float256{0xbfff_efff_ffff_ffff, 0xffff_ffff_ffff_ffff, 0xffff_ffff_ffff_ffff, 0xffff_ffff_ffff_ffff},
		},

		// special cases
		{exact256(1), exact256(1), exact256(1)},
		{exact256(0), exact256(0), exact256(0)},
		{exact256(0), exact256(math.Copysign(0, -1)), exact256(0)},
		{exact256(math.Copysign(0, -1)), exact256(0), exact256(math.Copysign(0, -1))},
		{exact256(math.NaN()), exact256(1), exact256(math.NaN())},
		{exact256(1), exact256(math.NaN()), exact256(math.NaN())},
	}
	for _, test := range tests {
		got := test.x.Nextafter(test.y)
		if !eq256(got, test.want) {
			t.Errorf("Float256(%x).Nextafter(%x) = %x, want %x", test.x, test.y, got, test.want)
		}
	}
}

func TestFloat256_Modf(t *testing.T) {
	tests := []struct {
		in       Float256
		wantInt  Float256
		wantFrac Float256
	}{
		{exact256(3.75), exact256(3.0), exact256(0.75)},

		// a < 0
		{exact256(-2.5), exact256(-2.0), exact256(-0.5)},
		{exact256(-0.5), exact256(math.Copysign(0, -1)), exact256(-0.5)},

		// a == 0
		{exact256(math.Copysign(0, -1)), exact256(math.Copysign(0, -1)), exact256(math.Copysign(0, -1))},
		{exact256(0), exact256(0), exact256(0)},

		// 0 < a < 1
		{exact256(0.5), exact256(0), exact256(0.5)},

		// special cases
		{exact256(math.Inf(1)), exact256(math.Inf(1)), exact256(math.NaN())},
		{exact256(math.Inf(-1)), exact256(math.Inf(-1)), exact256(math.NaN())},
		{exact256(math.NaN()), exact256(math.NaN()), exact256(math.NaN())},
	}
	for _, test := range tests {
		gotInt, gotFrac := test.in.Modf()
		if !eq256(gotInt, test.wantInt) || !eq256(gotFrac, test.wantFrac) {
			t.Errorf("Float256(%x).Modf() = (%x, %x), want (%x, %x)", test.in, gotInt, gotFrac, test.wantInt, test.wantFrac)
		}
	}
}

func BenchmarkFloat256_Modf(b *testing.B) {
	f := exact256(3.75)
	for b.Loop() {
		intPart, fracPart := f.Modf()
		runtime.KeepAlive(intPart)
		runtime.KeepAlive(fracPart)
	}
}

func TestFloat256_Frexp(t *testing.T) {
	tests := []struct {
		in       Float256
		wantFrac Float256
		wantExp  int
	}{
		{exact256(6.0), exact256(0.75), 3},
		{exact256(0.5), exact256(0.5), 0},
		{
			Float256{
				0x0000_0000_0000_0000, 0x0000_0000_0000_0000,
				0x0000_0000_0000_0000, 0x0000_0000_0000_0001,
			},
			exact256(0.5), -262377,
		},

		// special cases
		{exact256(0), exact256(0), 0},
		{exact256(math.Copysign(0, -1)), exact256(math.Copysign(0, -1)), 0},
		{exact256(math.Inf(1)), exact256(math.Inf(1)), 0},
		{exact256(math.Inf(-1)), exact256(math.Inf(-1)), 0},
		{exact256(math.NaN()), exact256(math.NaN()), 0},
	}
	for _, test := range tests {
		gotFrac, gotExp := test.in.Frexp()
		if !eq256(gotFrac, test.wantFrac) || gotExp != test.wantExp {
			t.Errorf("Float256(%x).Frexp() = (%x, %d), want (%x, %d)", test.in, gotFrac, gotExp, test.wantFrac, test.wantExp)
		}
	}
}

func TestFloat256_Ldexp(t *testing.T) {
	tests := []struct {
		frac Float256
		exp  int
		want Float256
	}{
		{exact256(0.75), 3, exact256(6.0)},
		{exact256(0.5), 0, exact256(0.5)},
		{
			exact256(0.5), 262144,
			Float256{
				0x7fff_e000_0000_0000, 0x0000_0000_0000_0000,
				0x0000_0000_0000_0000, 0x0000_0000_0000_0000,
			}, // 0x1p+262143
		},
		{
			exact256(0.5), -262377,
			Float256{
				0x0000_0000_0000_0000, 0x0000_0000_0000_0000,
				0x0000_0000_0000_0000, 0x0000_0000_0000_0001,
			}, // 0x1p-262378
		},

		// underflow
		{exact256(0.5), -262378, exact256(0)},
		{exact256(-0.5), -262378, exact256(math.Copysign(0, -1))},

		// overflow
		{exact256(1.0), 262144, exact256(math.Inf(1))},
		{exact256(-1.0), 262144, exact256(math.Inf(-1))},

		// special cases
		{exact256(0), 10, exact256(0)},
		{exact256(math.Copysign(0, -1)), 10, exact256(math.Copysign(0, -1))},
		{exact256(math.Inf(1)), 10, exact256(math.Inf(1))},
		{exact256(math.Inf(-1)), 10, exact256(math.Inf(-1))},
		{exact256(math.NaN()), 10, exact256(math.NaN())},
	}
	for _, test := range tests {
		got := test.frac.Ldexp(test.exp)
		if !eq256(got, test.want) {
			t.Errorf("Float256(%x).Ldexp(%d) = %x, want %x", test.frac, test.exp, got, test.want)
		}
	}
}
