package floats

import (
	"math"
	"testing"
)

func TestFloat128_Asin(t *testing.T) {
	tests := []struct {
		x    Float128
		want string
	}{
		{exact128(-1), "-1.570796326794896619231321691639751442098584699687552910487472296153908203143104499"},
		{exact128(-0.75), "-0.8480620789814810080529443389984180800733662132631126428607181635702008212284742343"},
		{exact128(-0.5), "-0.5235987755982988730771072305465838140328615665625176368291574320513027343810348331"},
		{exact128(-0.25), "-0.2526802551420786534856574369937109722521937330968381936339237787405750604810212224"},
		{exact128(0.25), "0.2526802551420786534856574369937109722521937330968381936339237787405750604810212224"},
		{exact128(0.5), "0.5235987755982988730771072305465838140328615665625176368291574320513027343810348331"},
		{exact128(0.75), "0.8480620789814810080529443389984180800733662132631126428607181635702008212284742343"},
		{exact128(1), "1.570796326794896619231321691639751442098584699687552910487472296153908203143104499"},
	}

	for _, tt := range tests {
		got := tt.x.Asin()
		if !close128(got, tt.want) {
			t.Errorf("Asin(%v) = %v; want %v", tt.x, got, tt.want)
		}
	}

	strictTests := []struct {
		x    Float128
		want Float128
	}{
		// special cases
		{exact128(0), exact128(0)},
		{exact128(math.Copysign(0, -1)), exact128(math.Copysign(0, -1))},
		{exact128(math.NaN()), exact128(math.NaN())},
		{exact128(2), exact128(math.NaN())},
		{exact128(-2), exact128(math.NaN())},
	}

	for _, tt := range strictTests {
		got := tt.x.Asin()
		if !eq128(got, tt.want) {
			t.Errorf("Asin(%v) = %v; want %v", tt.x, got, tt.want)
		}
	}
}

func TestFloat128_Acos(t *testing.T) {
	tests := []struct {
		x    Float128
		want string
	}{
		{exact128(-1), "3.141592653589793238462643383279502884197169399375105820974944592307816406286208999"},
		{exact128(-0.75), "2.418858405776377627284266030638169522171950912950665553348190459724109024371578734"},
		{exact128(-0.5), "2.094395102393195492308428922186335256131446266250070547316629728205210937524139332"},
		{exact128(-0.25), "1.823476581936975272716979128633462414350778432784391104121396074894483263624125722"},
		{exact128(0.25), "1.318116071652817965745664254646040469846390966590714716853548517413333142662083277"},
		{exact128(0.5), "1.047197551196597746154214461093167628065723133125035273658314864102605468762069666"},
		{exact128(0.75), "0.722734247813415611178377352641333362025218486424440267626754132583707381914630265"},
		{exact128(1), "0"},
	}

	for _, tt := range tests {
		got := tt.x.Acos()
		if !close128(got, tt.want) {
			t.Errorf("Acos(%v) = %v; want %v", tt.x, got, tt.want)
		}
	}

	strictTests := []struct {
		x    Float128
		want Float128
	}{
		// special cases
		{exact128(math.NaN()), exact128(math.NaN())},
		{exact128(2), exact128(math.NaN())},
		{exact128(-2), exact128(math.NaN())},
	}

	for _, tt := range strictTests {
		got := tt.x.Acos()
		if !eq128(got, tt.want) {
			t.Errorf("Acos(%v) = %v; want %v", tt.x, got, tt.want)
		}
	}
}

func TestFloat128_Atan(t *testing.T) {
	tests := []struct {
		x    Float128
		want string
	}{
		{exact128(-0.5), "-0.4636476090008061162142562314612144020285370542861202638109330887201978641657417053"},
		{exact128(-0.25), "-0.2449786631268641541720824812112758109141440983811840671273759146673551195876420966"},
		{exact128(-0.125), "-0.1243549945467614350313548491638710255731701917698040899151141191157222674275667586"},
		{exact128(0.125), "0.1243549945467614350313548491638710255731701917698040899151141191157222674275667586"},
		{exact128(0.25), "0.2449786631268641541720824812112758109141440983811840671273759146673551195876420966"},
		{exact128(0.5), "0.4636476090008061162142562314612144020285370542861202638109330887201978641657417053"},
		{exact128(0.75), "0.6435011087932843868028092287173226380415105911153123828656061187135124748116210887"},
		{exact128(1), "0.7853981633974483096156608458198757210492923498437764552437361480769541015715522497"},
		{exact128(2), "1.107148717794090503017065460178537040070047645401432646676539207433710338977362794"},
		{exact128(math.Inf(-1)), "-1.570796326794896619231321691639751442098584699687552910487472296153908203143104499"},
		{exact128(math.Inf(1)), "1.570796326794896619231321691639751442098584699687552910487472296153908203143104499"},
	}

	for _, tt := range tests {
		got := tt.x.Atan()
		if !close128(got, tt.want) {
			t.Errorf("Atan(%v) = %v; want %v", tt.x, got, tt.want)
		}
	}

	strictTests := []struct {
		x    Float128
		want Float128
	}{
		// special cases
		{exact128(0), exact128(0)},
		{exact128(math.Copysign(0, -1)), exact128(math.Copysign(0, -1))},
		{exact128(math.NaN()), exact128(math.NaN())},
	}

	for _, tt := range strictTests {
		got := tt.x.Atan()
		if !eq128(got, tt.want) {
			t.Errorf("Atan(%v) = %v; want %v", tt.x, got, tt.want)
		}
	}
}
